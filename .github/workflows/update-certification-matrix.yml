name: Update Certification Matrix

on:
  issues:
    types: [opened]

concurrency:
  group: update-certification-matrix
  cancel-in-progress: false

jobs:
  update-matrix:
    if: contains(github.event.issue.labels.*.name, 'certificate') && github.event.issue.milestone != null
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Update Certification Matrix
        uses: actions/github-script@v7
        with:
          script: |
            const { issue } = context.payload;
            const milestone = issue.milestone.title;
            
            // Extract and validate labels
            const procLabel = issue.labels.find(l => l.name.match(/^proc-\d+$/i));
            const distroLabel = issue.labels.find(l => l.name.match(/^os-[a-zA-Z]+(?:-[a-zA-Z0-9.]+)?$/i));
            if (!procLabel || !distroLabel) return console.log('Missing processor or OS label');
            
            const procSeries = procLabel.name.replace(/^proc-/i, '');
            const [, os, ...versionParts] = distroLabel.name.split('-');
            const version = versionParts.join(' ');
            const capitalize = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
            const osName = version ? `${capitalize(os)} ${version}` : capitalize(os);
            const osPattern = version 
              ? new RegExp(`^\\|\\s*${capitalize(os)}\\s+${version.replace(/\./g, '\\.')}\\s*\\|`, 'i')
              : new RegExp(`^\\|\\s*${capitalize(os)}\\s*\\|`, 'i');
            const certVersion = milestone.match(/^c(\d+\.\d+)/)?.[1];
            if (!certVersion) return console.log(`Invalid milestone format: ${milestone}`);

            console.log(`Updating ${osName} for processor ${procSeries}, cert ${certVersion}`);

            // Map processor series to their native certification level
            const processorNativeLevel = {
              '7003': '3.0',  // Milan
              '9004': '3.1',  // Genoa
              '8005': '4.0',  // Sorano
              '9005': '4.1'   // Turin
            };

            // Helper to get and decode file
            const getFile = async (path, ref) => {
              const { data } = await github.rest.repos.getContent({ owner: context.repo.owner, repo: context.repo.repo, path, ref });
              return { lines: Buffer.from(data.content, 'base64').toString('utf8').split('\n'), sha: data.sha };
            };

            // Helper function to update table rows
            const updateTable = (lines, tableStart, tableEnd, columnIndex) => {
              const certCell = `[${milestone}](${issue.html_url})`;
              
              // Try to update existing row
              for (let i = tableStart; i < tableEnd; i++) {
                if (osPattern.test(lines[i])) {
                  const cells = lines[i].split('|').map(c => c.trim());
                  const filteredCells = [cells[0], ...cells.slice(1).filter(c => c)];
                  while (filteredCells.length <= columnIndex) filteredCells.push('');
                  filteredCells[2] = '✅';
                  filteredCells[columnIndex + 1] = certCell;
                  lines[i] = filteredCells.join(' | ').replace(/^\s*\|?\s*/, '| ').replace(/\s*$/, ' |');
                  return;
                }
              }
              
              // Insert new row alphabetically
              let insertIndex = tableEnd;
              for (let i = tableStart; i < tableEnd; i++) {
                const match = lines[i].match(/^\|\s*([^|]+?)\s*\|/);
                if (match && osName.localeCompare(match[1].trim(), 'en', { sensitivity: 'base' }) < 0) {
                  insertIndex = i;
                  break;
                }
              }
              
              const cells = [osName, '✅'];
              while (cells.length < columnIndex) cells.push('');
              cells[columnIndex] = certCell;
              lines.splice(insertIndex, 0, '| ' + cells.join(' | ') + ' |');
            };

            // Use a single branch for all certification matrix updates
            const branchName = 'update-certification-matrix';
            const repo = { owner: context.repo.owner, repo: context.repo.repo };
            const { data: repoData } = await github.rest.repos.get(repo);
            const defaultBranch = repoData.default_branch;
            const { data: refData } = await github.rest.git.getRef({ ...repo, ref: `heads/${defaultBranch}` });
            
            // Check if PR exists
            const { data: existingPRs } = await github.rest.pulls.list({
              ...repo,
              state: 'open',
              head: `${context.repo.owner}:${branchName}`
            });
            
            // If no PR exists, delete and recreate branch; otherwise update it
            if (existingPRs.length === 0) {
              try {
                await github.rest.git.deleteRef({ ...repo, ref: `heads/${branchName}` });
                console.log('Deleted existing branch');
              } catch (e) {
                if (e.status !== 404) throw e;
              }
              await github.rest.git.createRef({ ...repo, ref: `refs/heads/${branchName}`, sha: refData.object.sha });
              console.log('Created fresh branch from main');
            } else {
              try {
                await github.rest.git.getRef({ ...repo, ref: `heads/${branchName}` });
                await github.rest.git.updateRef({ ...repo, ref: `heads/${branchName}`, sha: refData.object.sha, force: false }).catch(() => {});
              } catch (e) {
                if (e.status === 404) await github.rest.git.createRef({ ...repo, ref: `refs/heads/${branchName}`, sha: refData.object.sha });
              }
            }

            // Update certifications.md
            const certPath = 'docs/certifications.md';
            let { lines, sha } = await getFile(certPath, branchName);
            
            let tableStart = -1, tableEnd = -1, columnIndex = -1;
            
            // Find the specific processor section and its table
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Look for the exact processor section header (must be at start of line)
              if (line.startsWith(`AMD EPYC ${procSeries}`)) {
                console.log(`Found processor section at line ${i}: ${line}`);
                // Now find the table header in the next few lines
                for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
                  if (lines[j].includes('| OS |')) {
                    console.log(`Found table header at line ${j}`);
                    const headers = lines[j].split('|').map(h => h.trim()).filter(h => h);
                    columnIndex = headers.findIndex(h => h.includes(`${certVersion} Certification`));
                    if (columnIndex === -1) return console.log(`Column ${certVersion} Certification not found in processor ${procSeries} table`);
                    // Table data starts after header and separator line
                    tableStart = j + 2;
                    console.log(`Table starts at line ${tableStart}`);
                    
                    // Find table end - look for blank line or next processor section
                    for (let k = tableStart; k < lines.length; k++) {
                      if (lines[k].trim() === '' || lines[k].match(/^AMD EPYC \d+/)) {
                        tableEnd = k;
                        console.log(`Table ends at line ${tableEnd}`);
                        break;
                      }
                    }
                    if (tableEnd === -1) tableEnd = lines.length;
                    break;
                  }
                }
                break;
              }
            }
            if (tableStart === -1) return console.log(`Table for processor ${procSeries} not found`);
            
            console.log(`Updating table from line ${tableStart} to ${tableEnd}, column ${columnIndex}`);
            updateTable(lines, tableStart, tableEnd, columnIndex);
            await github.rest.repos.createOrUpdateFileContents({
              ...repo, path: certPath, message: `Update certification matrix for ${osName}`,
              content: Buffer.from(lines.join('\n')).toString('base64'), sha, branch: branchName
            });

            // Update README.md if native certification level
            if (processorNativeLevel[procSeries] === certVersion) {
              const readmePath = 'README.md';
              let { lines: readmeLines, sha: readmeSha } = await getFile(readmePath, branchName);
              const headerIdx = readmeLines.findIndex(l => l.includes('| OS |') && l.includes('Status'));
              
              if (headerIdx !== -1) {
                const headers = readmeLines[headerIdx].split('|').map(h => h.trim()).filter(h => h);
                const readmeColumnIndex = headers.findIndex(h => h.includes(`${certVersion} Certification`));
                
                if (readmeColumnIndex !== -1) {
                  const readmeTableStart = headerIdx + 2;
                  let readmeTableEnd = readmeLines.findIndex((l, i) => i > readmeTableStart && (l.trim() === '' || !l.includes('|')));
                  if (readmeTableEnd === -1) readmeTableEnd = readmeLines.length;
                  
                  updateTable(readmeLines, readmeTableStart, readmeTableEnd, readmeColumnIndex);
                  await github.rest.repos.createOrUpdateFileContents({
                    ...repo, path: readmePath, message: `Update master certification table for ${osName}`,
                    content: Buffer.from(readmeLines.join('\n')).toString('base64'), sha: readmeSha, branch: branchName
                  });
                }
              }
            }

            // Create or update PR
            if (existingPRs.length > 0) {
              await github.rest.issues.createComment({
                ...repo,
                issue_number: existingPRs[0].number,
                body: `Updated **${osName}** (${milestone}) - refs #${issue.number}`
              });
            } else {
              await github.rest.pulls.create({
                ...repo,
                title: 'Update certification matrix',
                head: branchName,
                base: defaultBranch,
                body: `Automatically updating certification matrix.\n\nStarted with: **${osName}** (${milestone}) - refs #${issue.number}`
              });
            }
  close-duplicates:
    if: contains(github.event.issue.labels.*.name, 'certificate') && github.event.issue.milestone != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Close older certification issues with same OS label
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const milestone = issue.milestone.title;

            // Find the OS label and processor label
            const osLabel = issue.labels.find(label =>
              label.name.match(/^os-[a-zA-Z]+(?:-[a-zA-Z0-9.]+)?$/i)
            );
            const procLabel = issue.labels.find(label =>
              label.name.match(/^proc-\d+$/i)
            );

            if (!osLabel || !procLabel) {
              console.log('No OS or processor label found, skipping duplicate check.');
              return;
            }

            // Get all open issues in the same milestone
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              milestone: issue.milestone.number,
              per_page: 100
            });

            for (const other of allIssues) {
              if (other.number === issue.number) continue;
              
              // Skip pull requests (PRs are also returned by issues API)
              if (other.pull_request) continue;

              // Check if other issue has the same three labels
              const hasCertLabel = other.labels.some(l => l.name === 'certificate');
              const hasSameOsLabel = other.labels.some(l => l.name === osLabel.name);
              const hasSameProcLabel = other.labels.some(l => l.name === procLabel.name);

              if (hasCertLabel && hasSameOsLabel && hasSameProcLabel) {
                console.log(`Closing older duplicate issue #${other.number} for ${osLabel.name} on ${procLabel.name}`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: other.number,
                  body: `Closing as duplicate of #${issue.number} (newer certification issue for **${osLabel.name}** on **${procLabel.name}** milestone **${milestone}**).`
                });

                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: other.number,
                  state: 'closed'
                });
              }
            }
