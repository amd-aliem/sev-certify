name: Update Certification Matrix

on:
  issues:
    types: [opened]

concurrency:
  group: certification-matrix-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  update-matrix:
    if: contains(github.event.issue.labels.*.name, 'certificate') && github.event.issue.milestone != null
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Update Certification Matrix
        uses: actions/github-script@v7
        with:
          script: |
            const { issue } = context.payload;
            const milestone = issue.milestone.title;
            
            // Extract and validate labels
            const procLabel = issue.labels.find(l => l.name.match(/^proc-\d+$/i));
            const distroLabel = issue.labels.find(l => l.name.match(/^os-[a-zA-Z]+(?:-[a-zA-Z0-9.]+)?$/i));
            if (!procLabel || !distroLabel) return console.log('Missing processor or OS label');
            
            const procSeries = procLabel.name.replace(/^proc-/i, '');
            const [, os, ...versionParts] = distroLabel.name.split('-');
            const version = versionParts.join(' ');
            const capitalize = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
            const osName = version ? `${capitalize(os)} ${version}` : capitalize(os);
            const osPattern = version 
              ? new RegExp(`^\\|\\s*${capitalize(os)}\\s+${version.replace(/\./g, '\\.')}\\s*\\|`, 'i')
              : new RegExp(`^\\|\\s*${capitalize(os)}\\s*\\|`, 'i');
            const certVersion = milestone.match(/^c(\d+\.\d+)/)?.[1];
            if (!certVersion) return console.log(`Invalid milestone format: ${milestone}`);

            console.log(`Updating ${osName} for processor ${procSeries}, cert ${certVersion}`);

            // Map processor series to their native certification level
            const processorNativeLevel = {
              '7003': '3.0',  // Milan
              '9004': '3.1',  // Genoa
              '8005': '4.0',  // Sorano
              '9005': '4.1'   // Turin
            };

            // Helper to get and decode file
            const getFile = async (path, ref) => {
              const { data } = await github.rest.repos.getContent({ owner: context.repo.owner, repo: context.repo.repo, path, ref });
              return { lines: Buffer.from(data.content, 'base64').toString('utf8').split('\n'), sha: data.sha };
            };

            // Helper function to update table rows
            const updateTable = (lines, tableStart, tableEnd, columnIndex) => {
              const certCell = `[${milestone}](${issue.html_url})`;
              
              // Try to update existing row
              for (let i = tableStart; i < tableEnd; i++) {
                if (osPattern.test(lines[i])) {
                  const cells = lines[i].split('|').map(c => c.trim());
                  const filteredCells = [cells[0], ...cells.slice(1).filter(c => c)];
                  while (filteredCells.length <= columnIndex) filteredCells.push('');
                  filteredCells[2] = '✅';
                  filteredCells[columnIndex + 1] = certCell;
                  lines[i] = filteredCells.join(' | ').replace(/^\s*\|?\s*/, '| ').replace(/\s*$/, ' |');
                  return;
                }
              }
              
              // Insert new row alphabetically
              let insertIndex = tableEnd;
              for (let i = tableStart; i < tableEnd; i++) {
                const match = lines[i].match(/^\|\s*([^|]+?)\s*\|/);
                if (match && osName.localeCompare(match[1].trim(), 'en', { sensitivity: 'base' }) < 0) {
                  insertIndex = i;
                  break;
                }
              }
              
              const cells = [osName, '✅'];
              while (cells.length < columnIndex) cells.push('');
              cells[columnIndex] = certCell;
              lines.splice(insertIndex, 0, '| ' + cells.join(' | ') + ' |');
            };

            // Setup branch and repo
            const branchName = 'update-certification-matrix';
            const repo = { owner: context.repo.owner, repo: context.repo.repo };
            const { data: repoData } = await github.rest.repos.get(repo);
            const defaultBranch = repoData.default_branch;
            const { data: refData } = await github.rest.git.getRef({ ...repo, ref: `heads/${defaultBranch}` });
            const { data: existingPRs } = await github.rest.pulls.list({ ...repo, state: 'open', head: `${context.repo.owner}:${branchName}` });
            
            // Delete and recreate branch if no PR exists, otherwise update it
            if (existingPRs.length === 0) {
              await github.rest.git.deleteRef({ ...repo, ref: `heads/${branchName}` }).catch(e => { if (e.status !== 404) throw e; });
              await github.rest.git.createRef({ ...repo, ref: `refs/heads/${branchName}`, sha: refData.object.sha });
            } else {
              await github.rest.git.updateRef({ ...repo, ref: `heads/${branchName}`, sha: refData.object.sha, force: false }).catch(() => {});
            }

            // Helper to find table boundaries in certifications.md
            const findTable = (lines, procSeries, certVersion) => {
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].startsWith(`AMD EPYC ${procSeries}`)) {
                  for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
                    if (lines[j].includes('| OS |')) {
                      const headers = lines[j].split('|').map(h => h.trim()).filter(h => h);
                      const columnIndex = headers.findIndex(h => h.includes(`${certVersion} Certification`));
                      if (columnIndex === -1) return null;
                      const tableStart = j + 2; // Start after separator line
                      let tableEnd = tableStart;
                      // Find table end - stop at blank line or next section
                      for (let k = tableStart; k < lines.length; k++) {
                        if (lines[k].trim() === '' || lines[k].match(/^AMD EPYC \d+/)) {
                          tableEnd = k;
                          break;
                        }
                        tableEnd = k + 1; // Include current row
                      }
                      return { tableStart, tableEnd, columnIndex };
                    }
                  }
                }
              }
              return null;
            };

            // Update certifications.md
            const certPath = 'docs/certifications.md';
            let { lines, sha } = await getFile(certPath, branchName);
            const table = findTable(lines, procSeries, certVersion);
            if (!table) return console.log(`Table or column not found for processor ${procSeries}, cert ${certVersion}`);
            
            updateTable(lines, table.tableStart, table.tableEnd, table.columnIndex);
            await github.rest.repos.createOrUpdateFileContents({
              ...repo, path: certPath, message: `Update certification matrix for ${osName}`,
              content: Buffer.from(lines.join('\n')).toString('base64'), sha, branch: branchName
            });

            // Update README.md if native certification level
            if (processorNativeLevel[procSeries] === certVersion) {
              const readmePath = 'README.md';
              let { lines: readmeLines, sha: readmeSha } = await getFile(readmePath, branchName);
              const headerIdx = readmeLines.findIndex(l => l.includes('| OS |') && l.includes('Status'));
              
              if (headerIdx !== -1) {
                const headers = readmeLines[headerIdx].split('|').map(h => h.trim()).filter(h => h);
                const readmeColumnIndex = headers.findIndex(h => h.includes(`${certVersion} Certification`));
                
                if (readmeColumnIndex !== -1) {
                  const readmeTableStart = headerIdx + 2;
                  let readmeTableEnd = readmeLines.findIndex((l, i) => i > readmeTableStart && (l.trim() === '' || !l.includes('|')));
                  if (readmeTableEnd === -1) readmeTableEnd = readmeLines.length;
                  
                  updateTable(readmeLines, readmeTableStart, readmeTableEnd, readmeColumnIndex);
                  await github.rest.repos.createOrUpdateFileContents({
                    ...repo, path: readmePath, message: `Update master certification table for ${osName}`,
                    content: Buffer.from(readmeLines.join('\n')).toString('base64'), sha: readmeSha, branch: branchName
                  });
                }
              }
            }

            // Create or update PR
            if (existingPRs.length > 0) {
              await github.rest.issues.createComment({
                ...repo,
                issue_number: existingPRs[0].number,
                body: `Updated **${osName}** (${milestone}) - refs #${issue.number}`
              });
            } else {
              await github.rest.pulls.create({
                ...repo,
                title: 'Update certification matrix',
                head: branchName,
                base: defaultBranch,
                body: `Automatically updating certification matrix.\n\nStarted with: **${osName}** (${milestone}) - refs #${issue.number}`
              });
            }
  close-duplicates:
    if: contains(github.event.issue.labels.*.name, 'certificate') && github.event.issue.milestone != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Close older certification issues with same OS label
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const milestone = issue.milestone.title;

            // Find the OS label and processor label
            const osLabel = issue.labels.find(label =>
              label.name.match(/^os-[a-zA-Z]+(?:-[a-zA-Z0-9.]+)?$/i)
            );
            const procLabel = issue.labels.find(label =>
              label.name.match(/^proc-\d+$/i)
            );

            if (!osLabel || !procLabel) {
              console.log('No OS or processor label found, skipping duplicate check.');
              return;
            }

            // Get all open issues in the same milestone
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              milestone: issue.milestone.number,
              per_page: 100
            });

            const repo = { owner: context.repo.owner, repo: context.repo.repo };
            
            for (const other of allIssues) {
              if (other.number === issue.number || other.pull_request) continue;
              
              const hasAllLabels = other.labels.some(l => l.name === 'certificate') &&
                                   other.labels.some(l => l.name === osLabel.name) &&
                                   other.labels.some(l => l.name === procLabel.name);

              if (hasAllLabels) {
                await github.rest.issues.createComment({
                  ...repo,
                  issue_number: other.number,
                  body: `Closing as duplicate of #${issue.number} (newer certification for **${osLabel.name}** on **${procLabel.name}**, milestone **${milestone}**)`
                });
                await github.rest.issues.update({ ...repo, issue_number: other.number, state: 'closed' });
              }
            }
